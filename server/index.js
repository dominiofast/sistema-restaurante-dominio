import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import { createPedido, createPedidoItem, createPedidoItemAdicional, authenticateUser, createSuperadmin, getPedidosByCompany, updatePedidoStatus, importCardapioCompleto } from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const app = express();

// Middleware
app.use(express.json({ limit: '10mb' }));

// CORS middleware
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

app.use(express.static(path.join(__dirname, '../dist')));

// PostgreSQL Neon configurado automaticamente via DATABASE_URL
console.log('üîó PostgreSQL conectado via DATABASE_URL:', !!process.env.DATABASE_URL);

// HEALTHCHECK ENDPOINT
app.get('/api/orders', (req, res) => {
  res.json({
    ok: true,
    hasDatabase: !!process.env.DATABASE_URL,
    database: 'neon-postgresql',
    timestamp: new Date().toISOString(),
    environment: 'express'
  });
});

// üìã ENDPOINT PARA BUSCAR PEDIDOS
app.get('/api/pedidos', async (req, res) => {
  console.log('üìã API /pedidos - Buscando pedidos:', { 
    companyId: req.query.company_id,
    query: req.query 
  });

  try {
    const { company_id } = req.query;

    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: 'company_id √© obrigat√≥rio'
      });
    }

    const pedidos = await getPedidosByCompany(company_id);

    console.log(`‚úÖ Pedidos encontrados: ${pedidos.length}`);

    res.json({
      success: true,
      data: pedidos,
      count: pedidos.length
    });

  } catch (error) {
    console.error('üí• API /pedidos - Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// üîÑ ENDPOINT PARA ATUALIZAR STATUS DO PEDIDO
app.put('/api/pedidos/:id/status', async (req, res) => {
  console.log('üîÑ API PUT /pedidos/:id/status - Atualizando status:', {
    pedidoId: req.params.id,
    status: req.body.status
  });

  try {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
      return res.status(400).json({
        success: false,
        error: 'Status √© obrigat√≥rio'
      });
    }

    const pedidoAtualizado = await updatePedidoStatus(parseInt(id), status);

    console.log(`‚úÖ Status atualizado com sucesso: ${pedidoAtualizado.id} -> ${pedidoAtualizado.status}`);

    res.json({
      success: true,
      data: pedidoAtualizado,
      message: `Status atualizado para: ${status}`
    });

  } catch (error) {
    console.error('üí• API PUT /pedidos/:id/status - Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ENDPOINT DE LOGIN/AUTENTICA√á√ÉO
app.post('/api/login', async (req, res) => {
  console.log('üîê API /login - Tentativa de login:', { email: req.body.email });

  try {
    const { email, password } = req.body;

    // Valida√ß√£o b√°sica
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email e senha s√£o obrigat√≥rios'
      });
    }

    // Autenticar usu√°rio
    const user = await authenticateUser(email, password);

    if (!user) {
      console.log('‚ùå Login falhou - credenciais inv√°lidas');
      return res.status(401).json({
        success: false,
        error: 'Email ou senha incorretos'
      });
    }

    console.log('‚úÖ Login realizado com sucesso:', { email: user.email, role: user.role });

    // Retornar dados do usu√°rio (sem senha)
    res.json({
      success: true,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        created_at: user.created_at
      },
      message: 'Login realizado com sucesso'
    });

  } catch (error) {
    console.error('üí• API /login - Erro interno:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// ENDPOINT PARA CRIAR SUPERADMIN
app.post('/api/create-superadmin', async (req, res) => {
  console.log('üëë API /create-superadmin - Criando superadmin');

  try {
    const result = await createSuperadmin();

    if (result.exists) {
      console.log('‚úÖ Superadmin j√° existe:', result.user);
      return res.json({
        success: true,
        message: 'Superadmin j√° existe',
        user: result.user
      });
    }

    console.log('‚úÖ Superadmin criado com sucesso:', result.user);

    res.json({
      success: true,
      message: 'Superadmin criado com sucesso',
      user: result.user
    });

  } catch (error) {
    console.error('üí• API /create-superadmin - Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ENDPOINT PARA IMPORTAR CARD√ÅPIO (CATEGORIAS E ADICIONAIS) - REQUER AUTENTICA√á√ÉO
app.post('/api/import/cardapio', async (req, res) => {
  console.log('üìã API /import/cardapio - Iniciando importa√ß√£o');

  // TODO: Adicionar autentica√ß√£o adequada aqui
  // Por enquanto, verificar se h√° uma basic validation do company_id
  
  try {
    const { company_id, categorias, adicionais } = req.body;

    // Valida√ß√£o b√°sica
    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: 'company_id √© obrigat√≥rio'
      });
    }

    if (!categorias || !Array.isArray(categorias)) {
      return res.status(400).json({
        success: false,
        error: 'categorias deve ser um array'
      });
    }

    if (!adicionais || !Array.isArray(adicionais)) {
      return res.status(400).json({
        success: false,
        error: 'adicionais deve ser um array'
      });
    }

    console.log(`üìä Importando: ${categorias.length} categorias, ${adicionais.length} adicionais para empresa ${company_id}`);

    // Importar via fun√ß√£o transacional
    const result = await importCardapioCompleto({
      company_id,
      categorias,
      adicionais
    });

    console.log('‚úÖ Importa√ß√£o conclu√≠da:', result.stats);

    res.json({
      success: true,
      message: 'Card√°pio importado com sucesso',
      data: result
    });

  } catch (error) {
    console.error('üí• API /import/cardapio - Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Erro interno do servidor'
    });
  }
});

// ENDPOINT PARA CRIAR PEDIDOS DE FORMA SEGURA
app.post('/api/orders', async (req, res) => {
  console.log('üöÄ API /orders - Recebendo pedido:', {
    companyId: req.body.companyId,
    cliente: req.body.cliente?.nome,
    itens: req.body.itens?.length || 0
  });

  try {
    const pedidoData = req.body;

    // Valida√ß√£o b√°sica
    if (!pedidoData.companyId || !pedidoData.cliente?.nome || !pedidoData.itens?.length) {
      return res.status(400).json({
        success: false,
        error: 'Dados incompletos: companyId, cliente.nome e itens s√£o obrigat√≥rios'
      });
    }

    // 1. Gerar n√∫mero do pedido
    const numeroPedido = Math.floor(Math.random() * 10000) + 1000;
    console.log(`üî¢ N√∫mero do pedido gerado: ${numeroPedido}`);

    // 2. CRIAR PEDIDO com PostgreSQL
    const novoPedido = await createPedido({
      company_id: pedidoData.companyId,
      numero_pedido: numeroPedido,
      nome: pedidoData.cliente.nome,
      telefone: pedidoData.cliente.telefone || '',
      endereco: pedidoData.endereco || '',
      status: 'analise',
      total: pedidoData.total,
      pagamento: pedidoData.forma_pagamento || 'dinheiro',
      tipo: pedidoData.tipo || 'delivery',
      observacoes: pedidoData.observacoes || null
    });

    console.log('‚úÖ Pedido criado via PostgreSQL:', { id: novoPedido.id, numero: novoPedido.numero_pedido });

    // 3. CRIAR ITENS DO PEDIDO - VERS√ÉO SIMPLIFICADA COM FALLBACK
    const itensSalvos = [];
    
    for (const item of pedidoData.itens) {
      console.log(`üìù Processando item: ${item.nome}`);
      
      // TENTAR inser√ß√£o normal, mas SEMPRE continuar mesmo com erro
      let itemProcessado = null;
      
      try {
        const itemSalvo = await createPedidoItem({
          pedido_id: novoPedido.id,
          produto_id: item.produto_id || null,
          nome_produto: item.nome || item.name,
          quantidade: item.quantidade || item.quantity,
          valor_unitario: (item.preco || item.price || 0).toString(),
          valor_total: ((item.preco || item.price || 0) * (item.quantidade || item.quantity || 1)).toString(),
          observacoes: item.observacoes || null
        });

        if (itemSalvo) {
          console.log(`‚úÖ Item salvo via PostgreSQL: ${itemSalvo.nome_produto}`);
          itemProcessado = itemSalvo;
        }
      } catch (err) {
        console.warn(`‚ö†Ô∏è Erro PostgreSQL ignorado para item: ${item.nome}`, err.message);
      }
      
      // Se n√£o conseguiu salvar, criar item simulado para resposta
      if (!itemProcessado) {
        itemProcessado = {
          id: `temp_${crypto.randomUUID()}`,
          pedido_id: novoPedido.id,
          nome_produto: item.nome || item.name,
          quantidade: item.quantidade || item.quantity,
          valor_unitario: (item.preco || item.price || 0).toString(),
          valor_total: ((item.preco || item.price || 0) * (item.quantidade || item.quantity || 1)).toString(),
          observacoes: item.observacoes || null
        };
        console.log(`‚úÖ Item simulado criado: ${itemProcessado.nome_produto}`);
      }
      
      // S√≥ adicionar √† lista de "salvos" se realmente foi salvo no banco (ID num√©rico)
      if (itemProcessado && typeof itemProcessado.id === 'number') {
        itensSalvos.push(itemProcessado);
      }

      // 4. SALVAR ADICIONAIS (se existirem) - PostgreSQL (apenas para itens reais)
      if (item.adicionais?.length && typeof itemProcessado.id === 'number') {
        for (const adicional of item.adicionais) {
          try {
            const adicionalSalvo = await createPedidoItemAdicional({
              pedido_item_id: itemProcessado.id,
              categoria_nome: 'Adicional',
              nome_adicional: adicional.name,
              quantidade: adicional.quantity,
              valor_unitario: adicional.price.toString(),
              valor_total: (adicional.price * adicional.quantity).toString()
            });

            console.log(`‚úÖ Adicional salvo via PostgreSQL: ${adicionalSalvo.nome_adicional}`);
          } catch (adicionalError) {
            console.error('‚ùå Erro ao salvar adicional PostgreSQL:', adicionalError.message);
          }
        }
      }
    }

    // 5. RESPOSTA DE SUCESSO
    const resposta = {
      success: true,
      pedido: {
        id: novoPedido.id,
        numero_pedido: novoPedido.numero_pedido,
        status: novoPedido.status,
        total: novoPedido.total
      },
      itens_salvos: itensSalvos.length,
      total_itens: pedidoData.itens.length
    };

    console.log('üéâ PEDIDO CRIADO COM SUCESSO:', resposta);
    res.json(resposta);

  } catch (error) {
    console.error('üí• API /orders - Erro interno:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Erro interno do servidor'
    });
  }
});

// SPA - Serve frontend para todas as rotas exceto /api (regex compat√≠vel com Express 5)
app.get(/^\/(?!api\/).*/, (req, res) => {
  res.sendFile(path.join(__dirname, '../dist/index.html'));
});

// Inicializar servidor
const PORT = process.env.PORT || 5000;
app.listen(PORT, '0.0.0.0', async () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üîó PostgreSQL conectado via DATABASE_URL: ${process.env.DATABASE_URL ? '‚úÖ' : '‚ùå'}`);
  
  // üî• CRIAR SUPERADMIN AUTOMATICAMENTE EM PRODU√á√ÉO
  try {
    console.log('üëë Verificando/criando superadmin automaticamente...');
    const superadminResult = await createSuperadmin();
    
    if (superadminResult.exists) {
      console.log('‚úÖ Superadmin j√° existe:', superadminResult.user.email);
    } else {
      console.log('üéâ Superadmin criado automaticamente:', superadminResult.user.email);
    }
  } catch (error) {
    console.error('‚ùå Erro ao criar superadmin automaticamente:', error.message);
    console.error('‚ö†Ô∏è  O login pode n√£o funcionar at√© o superadmin ser criado manualmente.');
  }
});